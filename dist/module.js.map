{"mappings":";;;;;;;;;;;;;;AIGA,MAAM,gCAAU,CAAC,OAAe,KAAU;IACxC,mDAAmD;IACnD,IAAI,OAAO,QAAQ,UAAU;QAC3B,iFAAiF;QACjF,IAAI,OAAO,QAAQ,YAAY;YAC7B,MAAM,WAAW,IAAI,MAAM,OAAO;YAClC,MAAM,OAAO,GAAG;YAChB,OAAO;QACT;QACA,oFAAoF;QACpF,IAAI,CAAC,OAAO;YACV,aAAa;YACb,MAAM,OAAO,GAAG;YAChB,OAAO;QACT;QACA,+DAA+D;QAC/D,IAAI,OAAO,MAAM,OAAO,KAAK,UAAU,QAAQ;aAE1C,MAAM,OAAO,CAAC,IAAI,GAAG;IAC5B,OAAO,IAAI,OAAO,QAAQ,UACxB,MAAM,OAAO,GAAG;IAElB,OAAO;AACT;AAEA,MAAM,gCAA4C,CAAC,OAAO;IACxD,MAAM,OAAE,GAAG,SAAE,KAAK,EAAE,GAAG,OAAO,OAAO;IAG7B,OAAO,GAAG;IAEd,OAAO,8BAAQ,OAAO,KAAK;AAGjC;IAEA,2CAAe;;;AEvCR,MAAM,4CAAe,CAAC;AACtB,MAAM,4CAAc;IACvB,QAAQ;AACZ;;;IDCA,2CAAe,CACb,OACA;IAEA,8EAA8E;IAC9E,OAAO;QACL,QAAQ,CAAC,KAAc;YACrB,SAAS;gBACP,KAAK,CAAA,GAAA,yCAAU,EAAE,MAAM;gBACvB,SAAS;yBACP;2BACA;gBACF;YACF;QACF;IACF;AACF;;;;;AFPO,MAAM,0DAAwB,CAAA,GAAA,oBAAY;AAE1C,MAAM,4CAA6C,CAAC,YACzD,QAAQ,gBACR,YAAY,EACb;IACC,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,iBAAS,EAIjC,CAAC,OAAO,WAAa,CAAA,GAAA,wCAAM,EAAE,CAAA,GAAA,aAAA,EAAE,SAAS,CAAC,QAAQ,WACjD;QAAE,SAAS,CAAC;IAAE,GACd,IAAO,CAAA;YACL,qDAAqD;YACrD,SACE,OAAO,IAAI,CAAC,CAAA,GAAA,yCAAW,GAAG,MAAM,IAAI,eAChC,OAAO,MAAM,CAAC,CAAC,GAAG,CAAA,GAAA,yCAAW,GAAG,gBAChC;QACR,CAAA;IAGF,MAAM,YAAY,CAAA,GAAA,cAAM,EAAE,IAAM,CAAA,GAAA,wCAAgB,EAAE,OAAO,WAAW;QAAC;KAAM;IAE3E,qBACE,mBAAC,0CAAsB,QAAQ;QAC7B,OAAO;YACL,OAAO,MAAM,OAAO;uBACpB;QACF;kBAEC;;;;;;AAGP;;;;;;;AI1CO,MAAM,4CAA2C,CAAC;IACvD,MAAM,UAAU,CAAA,GAAA,iBAAS,EAAE,CAAA,GAAA,yCAAoB;IAE/C,IAAI,CAAC,SACH,MAAM,MACJ;IAGJ,CAAA,GAAA,gBAAQ,EAAE;QACR,IAAI,OAAO,SAAS,aAAa,QAAQ,SAAS,CAAC,MAAM,CAAC;IAC5D,GAAG,EAAE;IAEL,OAAO;QAAC,QAAQ,KAAK;QAAS,QAAQ,SAAS,CAAC,MAAM;QAAE,QAAQ,SAAS;KAAC;AAC5E;;","sources":["src/index.ts","src/react-hook.ts","src/provider/index.ts","src/provider/provider.tsx","src/provider/reducer.ts","src/provider/functions.ts","src/provider/constants.ts","src/hooks/shared_simple_state.ts"],"sourcesContent":["export * from './react-hook'","export { ReactStateHookProvider } from \"./provider\";\nimport { useSharedSimpleHook } from \"./hooks/shared_simple_state\";\n\nexport { useSharedSimpleHook };\n","export * from './provider'","import React, { Reducer, createContext, useMemo, useReducer } from \"react\";\nimport {\n  IDispatchAction,\n  IProviderContext,\n  IReactHookProvider,\n  IState,\n} from \"./types.d\";\nimport reducer from \"./reducer\";\nimport providerFunctions from \"./functions\";\nimport { INTIAL_STATE } from \"./constants\";\nimport _ from \"lodash\";\n\n// @ts-ignore\nexport const ReactStateHookContext = createContext<IProviderContext>();\n\nexport const ReactStateHookProvider: IReactHookProvider = ({\n  children,\n  initialState,\n}) => {\n  const [state, dispatch] = useReducer<\n    Reducer<IState, IDispatchAction>,\n    IState\n  >(\n    (state, dispatch) => reducer(_.cloneDeep(state), dispatch),\n    { current: {} },\n    () => ({\n      // Check if there is an initial state of the provider\n      current:\n        Object.keys(INTIAL_STATE).length || initialState\n          ? Object.assign({}, INTIAL_STATE, initialState)\n          : undefined,\n    })\n  );\n\n  const functions = useMemo(() => providerFunctions(state, dispatch), [state]);\n\n  return (\n    <ReactStateHookContext.Provider\n      value={{\n        state: state.current,\n        functions,\n      }}\n    >\n      {children}\n    </ReactStateHookContext.Provider>\n  );\n};\n","import { Reducer } from \"react\";\nimport { IDispatchAction, IProviderContext, IState } from \"./types.d\";\n\nconst updater = (state: IState, key: any, value: any) => {\n  // check if content type of key is string or object\n  if (typeof key !== \"object\") {\n    // if passed payload is a state updater function, then invoke it and update state\n    if (typeof key === \"function\") {\n      const newState = key(state.current);\n      state.current = newState;\n      return state;\n    }\n    // if there is no specific value as value payload, then set key's value as new state\n    if (!value) {\n      // @ts-ignore\n      state.current = key;\n      return state;\n    }\n    // if type of the state is string then we just update the value\n    if (typeof state.current !== \"object\") state = value;\n    // but if the type of state is object we will update it according to the key\n    else state.current[key] = value;\n  } else if (typeof key === \"object\") {\n    state.current = key;\n  }\n  return state;\n};\n\nconst reducer: Reducer<IState, IDispatchAction> = (state, action) => {\n  const { key, value } = action.payload;\n\n  // this switch case can be developed and has nested state updater\n  switch (action.key) {\n    default: {\n      return updater(state, key, value);\n    }\n  }\n};\n\nexport default reducer;\n","import { Dispatch } from \"react\";\nimport { IDispatchAction, IProviderContext } from \"./types.d\";\nimport { ACTION_KEYS } from \"./constants\";\n\nexport default (\n  state: IProviderContext[\"state\"],\n  dispatch: Dispatch<IDispatchAction>\n) => {\n  // this approach can help us to have helper functions to manage complex states\n  return {\n    update: (key: unknown, value?: unknown) => {\n      dispatch({\n        key: ACTION_KEYS.update,\n        payload: {\n          key,\n          value,\n        },\n      });\n    },\n  };\n};\n","export const INTIAL_STATE = {}\nexport const ACTION_KEYS = {\n    update: 'update'\n}","import { useContext, useEffect } from \"react\";\nimport { ReactStateHookContext } from \"../provider/provider\";\nimport { IUseSharedStateHook } from \"./types.d\";\n\nexport const useSharedSimpleHook: IUseSharedStateHook = (value) => {\n  const context = useContext(ReactStateHookContext);\n\n  if (!context) {\n    throw Error(\n      \"Please make sure you wrap your component that uses the shared mode hook with the shared mode hook provider.\"\n    );\n  }\n  useEffect(() => {\n    if (typeof value != \"undefined\") context.functions.update(value);\n  }, []);\n\n  return [context.state as any, context.functions.update, context.functions];\n};\n"],"names":[],"version":3,"file":"module.js.map","sourceRoot":"../"}