{"mappings":";;;;;;;;;;;;;;AIGA,MAAM,gCAAU,CAAC,OAAe,KAAU;IACxC,IAAI,CAAC,MAAM,OAAO,EAAE;QAClB,QAAQ,KAAK,CAAC;QACd,OAAO;IACT;IACA,mDAAmD;IACnD,IAAI,OAAO,QAAQ,UAAU;QAC3B,IAAI,CAAC,OAAO;YACV,aAAa;YACb,MAAM,OAAO,GAAG;YAChB,OAAO;QACT;QACA,+DAA+D;QAC/D,IAAI,OAAO,MAAM,OAAO,KAAK,UAAU,QAAQ;aAE1C,MAAM,OAAO,CAAC,IAAI,GAAG;IAC5B,OAAO,IAAI,OAAO,QAAQ,UACxB,MAAM,OAAO,GAAG;IAElB,OAAO;AACT;AAEA,MAAM,gCAA4C,CAAC,OAAO;IACxD,MAAM,OAAE,GAAG,SAAE,KAAK,EAAE,GAAG,OAAO,OAAO;IAC7B,OAAO,GAAG;IAEd,OAAO,8BAAQ,OAAO,KAAK;AAGjC;IAEA,2CAAe;;;AElCR,MAAM,4CAAe,CAAC;AACtB,MAAM,4CAAc;IACvB,QAAQ;AACZ;;;IDCA,2CAAe,CAAC,OAAkC;IAG9C,OAAO;QACH,QAAQ,CAAC,KAAc;YACnB,SAAS;gBACL,KAAK,CAAA,GAAA,yCAAU,EAAE,MAAM;gBACvB,SAAS;yBACL;2BACA;gBACJ;YACJ;QACJ;IACJ;AAEJ;;;;;AFNO,MAAM,0DAAmB,CAAA,GAAA,oBAAY;AAErC,MAAM,4CAAwC,CAAC,YACpD,QAAQ,gBACR,YAAY,EACb;IACC,MAAM,CAAC,OAAO,SAAS,GAAG,CAAA,GAAA,iBAAS,EAIjC,CAAC,OAAO,WAAa,CAAA,GAAA,wCAAM,EAAE,CAAA,GAAA,aAAA,EAAE,SAAS,CAAC,QAAQ,WACjD;QAAE,SAAS,CAAC;IAAE,GACd,IAAO,CAAA;YAAE,SAAS,OAAO,MAAM,CAAC,CAAC,GAAG,CAAA,GAAA,yCAAW,GAAG;QAAc,CAAA;IAGlE,MAAM,YAAY,CAAA,GAAA,cAAM,EAAE,IAAM,CAAA,GAAA,wCAAgB,EAAE,OAAO,WAAW;QAAC;KAAM;IAE3E,qBACE,mBAAC,0CAAiB,QAAQ;QACxB,OAAO;YACL,OAAO,MAAM,OAAO;uBACpB;QACF;kBAEC;;;;;;AAGP;;;;;;;AIpCO,MAAM,4CAA2C,CAAC;IACvD,MAAM,UAAU,CAAA,GAAA,iBAAS,EAAE,CAAA,GAAA,yCAAe;IAE1C,IAAI,CAAC,SACH,MAAM,MACJ;IAGJ,CAAA,GAAA,gBAAQ,EAAE;QACR,IAAI,OAAO,QAAQ,SAAS,CAAC,MAAM,CAAC;IACtC,GAAG,EAAE;IAEL,OAAO;QAAC,QAAQ,KAAK;QAAE,QAAQ,SAAS,CAAC,MAAM;KAAC;AAClD;;","sources":["src/index.ts","src/react-hook.ts","src/provider/index.ts","src/provider/provider.tsx","src/provider/reducer.ts","src/provider/functions.ts","src/provider/constants.ts","src/hooks/shared_simple_state.ts"],"sourcesContent":["export * from './react-hook'","export { ReactHookProvider } from './provider'\nimport {useSharedSimpleHook} from './hooks/shared_simple_state'\n\n\n\nexport {\n    useSharedSimpleHook\n}","export * from './provider'","import React, { Reducer, createContext, useMemo, useReducer } from \"react\";\nimport {\n  IDispatchAction,\n  IProviderContext,\n  IReactHookProvider,\n  IState,\n} from \"./types.d\";\nimport reducer from \"./reducer\";\nimport providerFunctions from \"./functions\";\nimport { INTIAL_STATE } from \"./constants\";\nimport _ from \"lodash\";\n\n// @ts-ignore\nexport const ReactHookContext = createContext<IProviderContext>();\n\nexport const ReactHookProvider: IReactHookProvider = ({\n  children,\n  initialState,\n}) => {\n  const [state, dispatch] = useReducer<\n    Reducer<IState, IDispatchAction>,\n    IState\n  >(\n    (state, dispatch) => reducer(_.cloneDeep(state), dispatch),\n    { current: {} },\n    () => ({ current: Object.assign({}, INTIAL_STATE, initialState) })\n  );\n\n  const functions = useMemo(() => providerFunctions(state, dispatch), [state]);\n\n  return (\n    <ReactHookContext.Provider\n      value={{\n        state: state.current,\n        functions,\n      }}\n    >\n      {children}\n    </ReactHookContext.Provider>\n  );\n};\n","import { Reducer } from \"react\";\nimport { IDispatchAction, IProviderContext, IState } from \"./types.d\";\n\nconst updater = (state: IState, key: any, value: any) => {\n  if (!state.current) {\n    console.error(\"Current state is undefined!\");\n    return state;\n  }\n  // check if content type of key is string or object\n  if (typeof key === \"string\") {\n    if (!value) {\n      // @ts-ignore\n      state.current = key;\n      return state;\n    }\n    // if type of the state is string then we just update the value\n    if (typeof state.current !== \"object\") state = value;\n    // but if the type of state is object we will update it according to the key\n    else state.current[key] = value;\n  } else if (typeof key === \"object\") {\n    state.current = key;\n  }\n  return state;\n};\n\nconst reducer: Reducer<IState, IDispatchAction> = (state, action) => {\n  const { key, value } = action.payload;\n  switch (action.key) {\n    default: {\n      return updater(state, key, value);\n    }\n  }\n};\n\nexport default reducer;\n","import { Dispatch } from \"react\";\nimport { IDispatchAction, IProviderContext } from \"./types.d\";\nimport { ACTION_KEYS } from \"./constants\";\n\nexport default (state: IProviderContext['state'], dispatch: Dispatch<IDispatchAction>) => {\n\n\n    return {\n        update: (key: unknown, value?: unknown) => {\n            dispatch({\n                key: ACTION_KEYS.update,\n                payload: {\n                    key,\n                    value\n                }\n            })\n        },\n    }\n\n}","export const INTIAL_STATE = {}\nexport const ACTION_KEYS = {\n    update: 'update'\n}","import { useContext, useEffect } from \"react\";\nimport { ReactHookContext } from \"../provider/provider\";\nimport { IUseSharedStateHook } from \"./types.d\";\n\nexport const useSharedSimpleHook: IUseSharedStateHook = (value) => {\n  const context = useContext(ReactHookContext);\n\n  if (!context) {\n    throw Error(\n      \"Please make sure you wrap your component that uses the shared mode hook with the shared mode hook provider.\"\n    );\n  }\n  useEffect(() => {\n    if (value) context.functions.update(value);\n  }, []);\n\n  return [context.state, context.functions.update];\n};\n"],"names":[],"version":3,"file":"module.js.map","sourceRoot":"../"}